/****************************************************************** 
	Licensed Materials - Property of IBM

	5698-WSE
	(C) Copyright IBM Corp. 2014-2015 All Rights Reserved.
	US Government Users Restricted Rights - Use, duplication,
	or disclosure restricted by GSA ADP Schedule Contract with
	IBM Corp.

*******************************************************************/
/*
*/
"use strict";

var assert = require("assert"),
    https = require("https"),
    qs = require("querystring"),
    url = require("url"),
    util = require("util");

// export all modules
exports.WAProcess = require("../helpers/WAProcess");
exports.Step = require('../helpers/Step');
exports.Trigger = require('../helpers/Trigger');
exports.TaskLibrary = require('../helpers/TaskLibrary');
exports.Variable = require('../helpers/Variable');
exports.TriggerFactory = require('../helpers/TriggerFactory');
exports.steps = {
		CommandStep : require('../helpers/steps/CommandStep'),
		DatabaseStep : require('../helpers/steps/DatabaseStep'),
		FileTransferStep : require('../helpers/steps/FileTransferStep'),
		JavaBatchStep : require('../helpers/steps/JavaBatchStep'),
		MqttStep : require('../helpers/steps/MqttStep'),
		RestfulStep : require('../helpers/steps/RestfulStep')
};

var ObjectType = {
    Task: "com.ibm.tws.simpleui.bus.Task"
}

function parseRestHomeURL( restHomeURL ) {
    var parsedUrl = url.parse( restHomeURL, true );
    
    var conn = {
        hostname: parsedUrl.hostname,
        port: parsedUrl.port,
        pathname: parsedUrl.pathname,
        engine: {
            name: parsedUrl.query.engineName,
            owner: parsedUrl.query.engineOwner
        },
        tenancy: parsedUrl.query.tenantId
    }
    
    if( parsedUrl.auth ) {
        var auth = parsedUrl.auth.split(":");
        conn.user = auth[0];
        conn.password = auth[1];
    }
    
    return conn;
}

function createConnection( options ) {
    function requireCondition( cond, message ) {
        if( ! cond ) {
            throw new Error( message );
        }
    }
    
    function requireOption( options, id, type ) {
        requireCondition( options, "Missing required options" );

        requireCondition( options.hasOwnProperty(id), "Missing required option '" + id + "'" );
        
        if( type ) {
            requireCondition( typeof options[id] == type, "Option '" + id + "' must be of type " + type );
        }
    }

	if(!options && process.env.VCAP_SERVICES) {
		var vcapServices = JSON.parse(process.env.VCAP_SERVICES);

		if(vcapServices.WorkloadScheduler) {
			options = vcapServices.WorkloadScheduler[0].credentials;
		}
	}

	if (typeof options == "string") {
		options = { url: options };
	}
	
	if (typeof options == "object" && options.url) {
		options = parseRestHomeURL(options.url);
	}

    requireOption( options, "hostname", "string" );
    requireOption( options, "port" );
    requireOption( options, "tenancy", "string" );
    requireOption( options, "engine", "object" );
    requireOption( options, "user", "string" );
    requireOption( options, "password", "string" );
    requireCondition( typeof options.engine.name == "string", "Option 'engine.name' is required and must be a string" );
    requireCondition( typeof options.engine.owner == "string", "Option 'engine.owner' is required and must be a string" );

    var enableLog = false;
    var sessionCookies = null;
    var sessionCsrfChallenge = "";
    var connection = {
        hostname: options.hostname,
        port: options.port,
        pathname: "/ibm/TWSWebUI/Simple/rest/",
        tenancy: options.tenancy,
        engine: {
            name: options.engine.name,
            owner: options.engine.owner
        },
        user: options.user,
        password: options.password
    };
	var authorization = 'Basic ' + new Buffer(connection.user + ':' + connection.password).toString('base64');
    
    var ServiceURL = {
        Jobs: "Jobs/",
        Login: "Status/RestoreSession",
        TaskHistory: "TaskHistory/",
        TaskLibrary: "TaskLibrary/",
        Tasks: "Tasks/",
        Workstations: "Workstations/",
        UserPreference: "UserPreference/",
        // Sub-services
        ActionList: "/ACTION_LIST",
        RunNow: "/RunNow",
        Rerun: "/Rerun"
    };
    
    function log( message ) {
        var logger = options.log || console.log;
        
        if( enableLog ) logger( "[WA " + Date.now() +"] " + util.inspect(message) );
    }
    
    function enableLogging( enable ) {
        enableLog = !! enable;
    }
    
    function fail( callback, error ) {
        log( "Operation failed: "+error.message );
        callback( error );
    }
    
    function cookiesToString( cookies ) {
        var result = [];
        
        for( var i=0; i<cookies.length; i++ ) {
            var c = cookies[i].split(";");
            result.push(c[0]);
        }
        
        log("Cookie=["+result.join(";")+"]");
        
        return result.join(";");
    }
    
    function createRequestOptions( method, service ) {
        var options = {
            hostname: connection.hostname,
            port: connection.port,
            method: method,
            headers: {
                'Authorization': authorization
            },
            rejectUnauthorized: false,
            agent: false
        };
        
        options.path = (service && service[0] == "/") ?
            service :
            connection.pathname + (service || "");
        
        if( sessionCookies ) {
            options.headers["Cookie"] = cookiesToString(sessionCookies);
        }
        
        return options;
    }
    
    function createError( message ) {
        var e = new Error( message );
        
        return e;
    }
    
    function sendHttpsRequest( options, payload, callback ) {
        log( "Sending HTTPS request..." );
        log( options );
    
        var req = https.request( options, function(res) {
            var resultString = '';
            
            res.setEncoding('utf8');
            
            res.on('data', function(chunk) {
                resultString += chunk;
            });
            
            res.on('error', function(e) {
                callback(e);
            });
            
            res.on('end', function() {
                if( res.statusCode === 200 ) {
                    callback( null, resultString );
                } 
                else {
                    var error = createError("HTTPS request completed with code "+res.statusCode);

                    error.requestInfo = {
                        hostname: options.hostname,
                        port: options.port,
                        path: options.path,
                        method: options.method,
                        statusCode: res.statusCode,
                        resultString: resultString
                    }
                    
                    fail( callback, error );
                }
            });
        });
        
        req.on("error", function(e) {
            fail( callback, e );
        });
        
        if( payload) {
            req.write(payload);
        }
        
        req.end();
    }
    
    function sendLoginRequest( method, service, callback ) {
        var options = createRequestOptions( method, service );
        
        options.headers["Content-Type"] = "text/plain";
        options.requestCert = true;
        
        log( options );
        
        var req = https.request( options, function (res) {
            var csrfChallenge = "";
        
            res.on('error', function(e) {
                fail( callback, error );
            });

            res.on('data', function(data) { // Node won't fire the "end" event without a "data" listener
                log("LOGIN data="+data);
            } );
            
            res.on('end', function() {
                log('Login request end, statusCode=' + res.statusCode);
                
                if( res.statusCode === 200 ) {
                    var jsessionIdOk = false;
                    
                    var cookies = res.headers["set-cookie"];
                    
                    if( cookies ) {
                        var jsessionCookieName = options.loginCookieName || "JSESSIONID_ibm_console";
                        
                        for( var i=0; i<cookies.length; i++ ) {
                            log( "Set-Cookie["+i+"] -> "+cookies[i] );
                            if( cookies[i].indexOf(jsessionCookieName) == 0 ) {
                                jsessionIdOk = true;
                                break;
                            }
                        }
                    }
                    
                    if( jsessionIdOk ) {
                        callback( null, {cookie:cookies,challenge:csrfChallenge} );
                    }
                    else {
                        fail( callback, createError("Unable to login (cookie not found)") );
                    }
                } 
                else {
                    fail( callback, createError("Login request failed with code "+res.statusCode) );
                }
            } );
        } );
        
        req.on("error", function(e) {
            fail( callback, e );
        });
        
        var login_info = "engineOwner:"+connection.engine.owner+",engineName:"+connection.engine.name+",tenantId:"+connection.tenancy;
        
        log( "Login info: "+login_info );

		req.write(login_info);
        
        req.end();
    }

    function invokeService( method, service, payload, callback ) {
        // Check parameters
        assert.equal( typeof method, "string", "Argument 'method' must be a string" );
        assert.equal( typeof service, "string", "Argument 'key' must be a string" );
        
        var content_type = "text/plain";
        
        if( typeof payload == "object" ) {
            payload = JSON.stringify(payload);
            content_type = 'application/json';
        }

        assert.equal( typeof payload, "string", "Argument 'payload' must be a string" );
        
        var content_length = payload.length;
        
        log( "Payload=" + payload + "[type="+content_type+"]" );
        
        callback = callback || function () {};
        
        assert.equal( typeof callback, "function", "Argument 'callback' must be a function" );

        // Set request options
        var options = createRequestOptions( method, service );
        
        options.headers["Content-Type"] = content_type;
        
        if( content_length ) {
            options.headers["Content-Length"] = content_length;
        }
        
        log( options );

        // Login if needed
        if( ! sessionCookies ) {
            log( "Cookie not found... logging in..." );
            
            sendLoginRequest( "POST",
                ServiceURL.Login,
                function (err,data) {
                    if( ! err ) {
                    }
                
                    if( err ) {
                        err.description = "Login failed";
                        callback( err );
                    }
                    else {
                        log( "Login successful, setting cookie" );
                        sessionCookies = data.cookie;
                        sessionCsrfChallenge = data.challenge || "";
                        options.headers["Cookie"] = cookiesToString(sessionCookies);
                        sendHttpsRequest( options, payload, callback );
                    }
                } 
            );
        }
        else {
            sendHttpsRequest( options, payload, callback );
        }
	}
    
    function unarray( data ) {
        if( Array.isArray(data) && data.length == 1 ) {
            data = data[0];
        }
        
        return data;
    }
    
    function cleanup( error, data, callback, extraneous_props, cleanup_handler ) {
        function cleanupItem( item ) {
            if( extraneous_props ) {
                for( var i=0; i<extraneous_props.length; i++ ) {
                    delete item[ extraneous_props[i] ];
                }
            }
        }
    
        if( error ) {
            callback( error );
        }
        else {
            if( typeof data == "string" && data.length > 0 ) {
                log( "JSON: "+data );
                data = JSON.parse(data);
            }
            
            if( Array.isArray(data) ) {
                for( var i=0; i<data.length; i++ ) {
                    cleanupItem( data[i] );
                }
            }
            else {
                cleanupItem( data );
            }
        
            if( cleanup_handler ) {
                data = cleanup_handler( data );
            }
            callback( null, data );
        }
    }
    
    function getWorkstations( options, callback ) {
        invokeService( "get", ServiceURL.Workstations, null, function (error,data) {
            cleanup( error, data, callback );
        } );
    }
    
    function getCloudWorkstation( callback ) {
    	var cloudAgentPrefix = options.tenancy;
   		var cloudAgent = cloudAgentPrefix + "_CLOUD";
   		callback(cloudAgent);
    }
    
    function getRecentTasksHistory( options, callback ) {
        var url = ServiceURL.TaskHistory;
        
        if( options && options.interval ) {
            assert.equal( typeof options.interval, "number", "Option 'interval' must be a number" );
            assert( options.interval > 0, "number", "Option 'interval' must be greater than zero" );
            
            url += "?interval=" + (options.interval | 0);
        }
        
        invokeService( "get", url, null, callback );
    }
    
    function getTasks( options, callback ) {
        requireOption( options, "id" );
        
        var url = ServiceURL.Tasks;
        
        url += "?tasklibraryid=" + options.id + "&dummy=1&sort=+name";
        
        invokeService( "get", url, null, function (error,data) {
            cleanup( error, data, callback, [] );
        } );
    }
    
    function getTask( options, callback ) {
        requireOption( options, "id" );
        
        invokeService( "get", ServiceURL.Tasks+options.id, null, function (error,data) {
            cleanup( error, data, callback, null, unarray );
        } );
    }
    
    function getTaskHistory( options, callback ) {
        requireOption( options, "id" );
        
        invokeService( "get", ServiceURL.TaskHistory+options.id, null, function (error,data) {
            cleanup( error, data, callback, ["originaltask"] );
        } );
    }
    
    function createTask( options, callback ) {
        if( options && options.objecttype == ObjectType.Task && options.hasOwnProperty("tasklibraryid") ) {
            options = {
                process: options,
                library: options.tasklibraryid
            }
        }

        requireOption( options, "process", "object" );
        requireOption( options, "library" );
        
        var task = options.process;
        
        task.creationdate = "";
        task.lastrunresult = -1;
        task.lastmodifiedtimestamp = "";
        task.isEditing = false;
        task.objecttype = ObjectType.Task;
        task.tasklibraryid = options.library;
        
        invokeService( "post", ServiceURL.Tasks, task, function (error,data) {
            cleanup( error, data, callback, null, unarray );
        } );
    }
       
    function createAndEnableTask( options, callback ) {
    	createTask( options, function(err, data){
    		if(err){
    			callback(err);
    		} else {
    			enableDisableTask(data, true, function(err, data){
    				if(err){
    					callback(err);
    				} else {
    					callback();
    				}
    			});
    		}
    	});
    }
    
    function enableDisableTask( options, enable, callback){
    	requireOption( options, "actions");
		if (options.actions.length == 0) {
			throw new Error("No action is present");
		} else {
			requireOption( options, "taskstatus" );
			options.taskstatus = enable;
	    	updateTask( options, function(err, data){
				if(err){
					callback(err);
				} else{
					callback();
				}
			});
		}
    }
    
    function updateTask( options, callback ) {
        requireOption( options, "id" );
        requireOption( options, "tasklibraryid" );
        
        var task = options;
        
        invokeService( "put", ServiceURL.Tasks+task.id, task, callback );
    }
    
    function deleteTask( options, callback ) {
        requireOption( options, "id" );
        
        invokeService( "delete", ServiceURL.Tasks+options.id, null, function (error,data) {
            cleanup( error, data, callback );
        } );
    }
    
    function runTask( options, callback ) {
        requireOption( options, "id" );

        var payload=null;
        
        if (options && options.variables) {
        	payload = { variables: options.variables };
        }
        
        invokeService( "put", ServiceURL.Tasks+options.id+ServiceURL.RunNow, payload, function (error,data) {
            cleanup( error, data, callback );
        } );
    }
    
    function getStepDetails( options, callback ) {
        requireOption( options, "step", "object" );
        requireCondition( options.processid || (options.process && options.process.id), "Missing required option 'processid' or 'process.id'" );
        requireCondition( options.step.id, "Missing required option 'step.id'" );
        requireCondition( options.step.instancetype, "Missing required option 'step.instancetype'" );
        
        var processid = options.processid || options.process.id;
        
        invokeService( "get", ServiceURL.TaskHistory+processid+"/"+options.step.id+"/"+options.step.instancetype, null, function (error,data) {
            cleanup( error, data, callback );
        } );
    }
    
    function getStepLogURLs( options, callback ) {
        requireOption( options, "id" );
        requireOption( options, "startdate" );
        requireOption( options, "instancetype" );
        requireOption( options, "jobnumber" );
        
        var info = "startDate:"+options.startdate+",instanceType:"+options.instancetype+",jobNumber:"+options.jobnumber;
        
        invokeService( "post", ServiceURL.Jobs+options.id+ServiceURL.ActionList, info, function (error,data) {
            cleanup( error, data, callback, [] );
        } );
    }
    
    function getStepLog( options, callback ) {
        requireOption( options, "download" );
        
        invokeService( "get", options.download, null, callback );
    }
    
    function getTaskLibraries( options, callback ) {
        invokeService( "get", ServiceURL.TaskLibrary, null, function (error,data) {
            cleanup( error, data, callback, ["tasks","children"] );
        } );
    }
    
    function createTaskLibrary( options, callback ) {
        requireOption( options, "name", "string" );
        
        var library = {
            name: options.name,
            parentid: options.parentid || -1
        };
        
        invokeService( "post", ServiceURL.TaskLibrary, library, function (error,data) {
            cleanup( error, data, callback, ["tasks","children"], unarray );
        } );
    }
    
    function updateTaskLibrary( options, callback ) {
        requireOption( options, "id" );
        requireOption( options, "parentid" );
        requireOption( options, "name", "string" );
        
        var library = options;
            
        invokeService( "put", ServiceURL.TaskLibrary+library.id, library, function (error,data) {
            cleanup( error, data, callback, ["tasks","children"] );
        } );
    }
    
	function deleteTaskLibrary( options, callback ) {
        requireOption( options, "id" );
        
        invokeService( "delete", ServiceURL.TaskLibrary + options.id, null, callback );
    }
	
	function getTimezone( callback ) {
		invokeService("get", ServiceURL.UserPreference, null, function(error,data){
			cleanup( error, data, callback);
		});
	}
    
	function setTimezone( options, callback ) {
		requireOption( options, "timezone");
		getTimezone(function (err, timezone){
			if (err) {
				callback(err);
			} else {
				if (timezone) {
					invokeService( "put", ServiceURL.UserPreference, options, function(error,data){
						cleanup( error, data, callback );
					});
				} else {
					invokeService( "post", ServiceURL.UserPreference, options, function(error,data){
						cleanup( error, data, callback );
					});
				}
			}
		});
	}

	return {
        // Utilities
        enableLogging: enableLogging,
        invokeService: invokeService,
        getTimezone: getTimezone,
        setTimezone: setTimezone,
        // Process library
        getProcessLibraries: getTaskLibraries,
        createProcessLibrary: createTaskLibrary,
        deleteProcessLibrary: deleteTaskLibrary,
        updateProcessLibrary: updateTaskLibrary,
        // Agent
        getAgents: getWorkstations,
        getCloudAgent: getCloudWorkstation,
        // Process
        getProcessesStatusOverview: getRecentTasksHistory,
        getProcesses: getTasks,
        getProcess: getTask,
        getProcessHistory: getTaskHistory,
        createProcess: createTask,
        createAndEnableProcess: createAndEnableTask,
        enableDisableProcess: enableDisableTask,
        deleteProcess: deleteTask,
        updateProcess: updateTask,
        runProcess: runTask,
        // Step
        getStepDetails: getStepDetails,
        getStepLogURLs: getStepLogURLs,
        getStepLog: getStepLog
    }
};

exports.createConnection = createConnection;
exports.parseRestHomeURL = parseRestHomeURL;